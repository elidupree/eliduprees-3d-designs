"""
Slightly hacky tool to help with writing the pyOCCT API wrappers.

Lots of boilerplate is needed, and I don't want to write it manually. My previous approach used internal Python meta-programming, but that made IDEs not understand what functions were available. So, now I use code generation.

This is only for top-level library code, so the design is as follows:

* When you want to generate code, you write `@generate_code` over a nullary function that returns a string.
* The goal is to make it so that every thus-tagged function also has the generated code under it, wrapped in the comments `# == Begin generated code ==` and `# == End generated code ==`
* When the interpreter reaches this function, it automatically runs it and calculates the generated code, then checks the current state of the file. If the generated code is already present, it does nothing more. If not present, it throws a GeneratedCodeNeedsUpdate exception.
* To handle these exceptions, you should put `this_file_uses_code_generation()` at the top of the module. This makes it so that when you run the module as __main__, it repeatedly executes the file, catches exceptions, and performs the actual code updates. Also, it deletes any generated-code blocks not induced by a @generate_code function (identified by their comments).
"""
import base64
import hashlib
import inspect
import importlib
import importlib.util
import os.path
import random
import re
import sys
# from collections import defaultdict
from typing import List, Tuple, Optional

from atomicwrites import atomic_write

# lines_added_this_run = defaultdict(int)

# class _CodegenState():
#     def __init__(self, file_path):
#         self.file_path = file_path
#
# _codegen_states = {}

# These are magic strings; if you edit them, you'll have to update any existing generated-code files too, or the lines will cease to be acknowledged as machine-generated
generated_code_hash_length = 5
generated_code_line_label = " #{}"
generated_code_start_label = "# == Code generated by `{}` (lines in this chunk end with a hash to prevent uncertainty about what code is machine-generated; the system will automatically replace such lines, so don't edit them) =="
generated_code_end_label = "# == End of code generated by `{}` =="


def _parse_start_label(line):
    regex = re.escape(generated_code_start_label).replace(re.escape("{}"), "([^`]*)")
    # print(regex, line)
    match = re.match(regex, line)
    if not match: return None
    return match[1]
def _line_label_of_generated_code_line(line):
    return line[-(len(generated_code_line_label) - 2 + generated_code_hash_length):]

def _labeled_line(raw_line, line_label):
    target_length = 80
    forced_length = len(raw_line) + len(line_label)
    return raw_line + " "*(target_length-forced_length) + line_label
def _unlabeled_line(labeled_line, line_label):
    assert(labeled_line[-len(line_label):] == line_label)
    return labeled_line[:-len(line_label)].rstrip()

def _full_generated_lines(generator_name, fn_hash, raw_lines):
    start_label = generated_code_start_label.format(generator_name)
    line_label = generated_code_line_label.format(fn_hash)
    end_label = generated_code_end_label.format(generator_name)
    return [
        _labeled_line(line, line_label) for line in
        [start_label] + raw_lines + [end_label]
    ]

def _gibberish_hash(digest):
    # ALWAYS mix letters, numbers, case, and never use vowels, so that it doesn't look like a word
    nonletters = "$&%@0123456789"
    letters = "bcdfghijklmnpqrstvwxyz"
    result = ""
    bytes = iter(digest)
    for i in range(generated_code_hash_length):
        # yeah these % have a bias; I don't need to care about that
        if ("_"+result)[-2:].isalpha() or next(bytes) < 100:
            result = result + nonletters[next(bytes) % len(nonletters)]
        else:
            char = letters[next(bytes) % len(letters)]
            if len(result) == 0 or result[-1].isupper() or (not result[-1].isalpha() and next(bytes) < 128):
                result = result + char
            else:
                result = result + char.upper()
    return result

def generate_code(code_generation_function):
    generator_name = code_generation_function.__name__
    # print(inspect.getsource(code_generation_function))
    hash_bytes = hashlib.blake2b(inspect.getsource(code_generation_function).encode()).digest()
    fn_hash = _gibberish_hash(hash_bytes)
    raw_generated_code = code_generation_function()
    raw_generated_lines = raw_generated_code.split("\n")
    file_path = inspect.getfile(code_generation_function)
    # 1-indexed
    code_generation_function_lines, code_generation_function_start_lineno = inspect.getsourcelines(code_generation_function)
    # 0-indexed
    lineidx_after_generator = (code_generation_function_start_lineno-1) + len(code_generation_function_lines) #+ lines_added_this_run[file_path]
    # first_existing_lineno_after_generated_code = code_generation_function_start_lineno + lines_added_this_run[file_path]

    # initially open read-only to check whether the code is there:
    needs_rewriting = False
    with open(file_path, "r") as file:
        old_code = file.read()
        existing_lines = old_code.splitlines()
        updated_lines = _lines_with_replacing_generated_code_at(lineidx_after_generator, existing_lines, _full_generated_lines(generator_name, fn_hash, raw_generated_lines))
        # corresponding_lines = existing_lines[lineidx_after_generator:][:len(full_generated_lines)]
        # # corresponding_lines = existing_lines[:first_existing_lineno_after_generated_code][:-len(full_generated_lines)]
        if updated_lines != existing_lines:
            print(f"Rewriting generated code for {generator_name}")
            new_code = "\n".join(updated_lines)
            raise GeneratedCodeNeedsUpdate(file_path, old_code, new_code)
            # print(f"mismatch: {corresponding_lines}, {full_generated_lines}")
            # needs_rewriting = True

    # if needs_rewriting:
    #     print(f"Rewriting generated code for {code_generation_function.__name__}")
    #
    #     # result_lines = existing_lines[:first_existing_lineno_after_generated_code]
    #     # try:
    #     #     existing_generated_code_back_index = first_existing_lineno_after_generated_code - 1
    #     #     if existing_lines[existing_generated_code_back_index] == end_label:
    #     #         existing_generated_code_start_index = existing_lines.index(generated_code_start_label, 0, existing_generated_code_back_index)
    #     #         result_lines = existing_lines[:existing_generated_code_start_index]
    #     #         lines_added_this_run[file_path] -= (first_existing_lineno_after_generated_code - existing_generated_code_start_index)
    #     # except (IndexError, ValueError):
    #     #     pass
    #     result_lines = existing_lines[:start_lineidx_for_generated_code]
    #
    #     first_lineno_afterwards = start_lineidx_for_generated_code
    #     try:
    #         if existing_lines[first_lineno_afterwards] == start_label:
    #             first_lineno_afterwards += 1
    #             while existing_lines[first_lineno_afterwards].endswith(generated_code_line_label):
    #                 first_lineno_afterwards += 1
    #             if existing_lines[first_lineno_afterwards] == end_label:
    #                 first_lineno_afterwards += 1
    #     except IndexError:
    #         pass
    #
    #     result_lines.extend(full_generated_lines)
    #     lines_added_this_run[file_path] += len(full_generated_lines)
    #     result_lines.extend(existing_lines[first_existing_lineno_after_generated_code:])
    #     result = "\n".join(result_lines)
    #     print(result)
    #
    #     # try:
    #     #     with atomic_write(file_path, overwrite=True) as file:
    #     #         file.write(result)
    #     # except IOError:
    #     #     print("Unable to rewrite source file")
    #
    #     exec("\n".join(full_generated_lines), code_generation_function.__globals__)

# def reload_if_changed():
#     pass

def _lines_with_removing_generated_code_before_first_generator(original_lines: List[str]) -> List[str]:
    i = 0
    result = []
    while i < len(original_lines):
        line = original_lines[i]
        # print(f"line {i}...")
        if line == "@generate_code":
            # print(f"found generator")
            result.extend(original_lines[i:])
            break
        start_of = _parse_start_label(line)
        if start_of is not None:
            # print(f"found generated code")
            label = _line_label_of_generated_code_line(line)
            while i < len(original_lines) and original_lines[i].endswith(label):
                # print(f"found more generated code")
                i += 1
            continue

        result.append(line)
        i += 1
    return result


def _closest_generated_code_chunk_starting_above(lines: List[str], line_index: int) -> Optional[Tuple[int, int, str]]:
    last_chunk_start_index = None
    last_chunk_end_index = None
    current_chunk_start_index = None
    last_chunk_label = None
    for i, line in enumerate(lines):
        if current_chunk_start_index is None:
            start_of = _parse_start_label(line)
            if start_of is None:
                if i >= line_index:
                    if last_chunk_start_index is not None:
                        return last_chunk_start_index, last_chunk_end_index, last_chunk_label
                    return None
            else:
                current_chunk_start_index = last_chunk_start_index = i
                last_chunk_label = _line_label_of_generated_code_line(line)
        else:
            if not line.endswith(last_chunk_label):
                last_chunk_end_index = i
                if i > line_index:
                    break
                current_chunk_start_index = None
    if current_chunk_start_index is not None:
        last_chunk_end_index = len(lines)
    if last_chunk_start_index is not None:
        return last_chunk_start_index, last_chunk_end_index, last_chunk_label


def _lines_with_replacing_generated_code_at_start(original_lines: List[str], generated_lines: List[str]) -> List[str]:
    cleaned = _lines_with_removing_generated_code_before_first_generator(original_lines)
    return generated_lines + cleaned


def _lines_with_replacing_generated_code_at(lineidx_after_generator: int, original_lines: List[str], generated_lines: List[str]) -> List[str]:
    return original_lines[:lineidx_after_generator] + _lines_with_replacing_generated_code_at_start(original_lines[lineidx_after_generator:], generated_lines)


def _remove_generated_code_before_first_generator(file_path):
    with open(file_path, "r") as file:
        existing_lines = list(file.read().splitlines())
    cleaned = _lines_with_removing_generated_code_before_first_generator(existing_lines)
    if cleaned != existing_lines:
        with atomic_write(file_path, overwrite=True) as file:
            file.write("\n".join(cleaned))


class GeneratedCodeNeedsUpdate(Exception):
    def __init__(self, file_path, old_code, new_code):
        self.file_path = file_path
        self.old_code = old_code
        self.new_code = new_code
        assert (new_code != old_code), "Constructed GeneratedCodeNeedsUpdate when the code didn't change!"

    def execute(self):
        with open(self.file_path, "r") as file:
            if file.read() != self.old_code:
                raise RuntimeError("Threw GeneratedCodeNeedsUpdate but the file on disk changed before we handled the exception? (Theoretically this should happen almost instantly, AND this doesn't protect from overwrites if the timing is slightly different, but this exception is here to protect from me theoretically-potentially making mistakes in the code where GeneratedCodeNeedsUpdate is handled a macroscopic amount of time later)")
        with atomic_write(self.file_path, overwrite=True) as file:
            file.write(self.new_code)


def _print_exception_during_update(exc_info, file_path):
    import traceback
    ty, exc, tb = exc_info
    # print(inspect.getframeinfo(tb.tb_frame).filename, file_path)
    while inspect.getframeinfo(tb.tb_frame).filename != file_path:
        tb = tb.tb_next
        # print(inspect.getframeinfo(tb.tb_frame).filename, file_path)
    traceback.print_exception(ty, exc, tb)

def _update_all_generated_code(file_path):
    _remove_generated_code_before_first_generator(file_path)
    attempts = 100
    for attempt in range(attempts):
        # print(f"attempt {attempt}")
        with open(file_path) as f:
            source_text = f.read()
        try:
            code = compile(source_text, file_path, "exec")
            # print("compiled")
        except SyntaxError as e:
            # print("SyntaxError")
            # We need special handling for syntax errors, because if you leave a syntax error in the generated code, you can't even rerun the generation.
            lines = source_text.splitlines()
            line_index = (e.end_lineno if hasattr(e, "end_lineno") else e.lineno) - 1

            chunk = _closest_generated_code_chunk_starting_above(lines, line_index)
            if chunk is None:
                # print("what")
                raise
            # print("ok", chunk)

            # thought of putting this at the start, but don't want to affect line numbers
            # ['"Code disabled due to syntax error (see below)"']+
            start, end, label = chunk
            def commented_line(line):
                if line.startswith("#"):
                    return line
                return _labeled_line("# " + _unlabeled_line(line, label), label)
            lines[start:end] = [commented_line(line) for line in lines[start:end]]
            lines.insert(min(line_index+1, end), _labeled_line(f'"{" "*e.offset}^ {e} "', label))
            with atomic_write(file_path, overwrite=True) as file:
                file.write("\n".join(lines))

            import traceback
            traceback.print_exception(SyntaxError, e, None)
            break

        try:
            globals = {"__name__": os.path.splitext(os.path.basename(file_path))[0]}
            exec(code, globals, globals)
            break
        except GeneratedCodeNeedsUpdate as e:
            # print("Generated code changed:", e.new_code)
            # In case we generate a syntax error, we want to be able to reload 1 more time (hopefully this will never matter because we won't run out of attempts, but just in case)
            if attempt + 1 < attempts:
                e.execute()
                continue
        except SyntaxError as e:
            assert False
        except:
            import traceback
            ty, exc, tb = sys.exc_info()
            while inspect.getframeinfo(tb.tb_frame).filename != file_path:
                tb = tb.tb_next
            traceback.print_exception(ty, exc, tb)
            break


def this_file_uses_code_generation():
    caller = inspect.currentframe().f_back
    if caller.f_globals["__name__"] == "__main__":
        _update_all_generated_code(caller.f_globals["__file__"])
        sys.exit(0)
