"""
Slightly hacky tool to help with writing the pyOCCT API wrappers.

Lots of boilerplate is needed, and I don't want to write it manually. My previous approach used internal Python meta-programming, but that made IDEs not understand what functions were available. So, now I use code generation.

This is only for top-level library code, so the design is as follows:

* When you want to generate code, you write `@generate_code` over a nullary function that returns a string.
* The goal is to make it so that every thus-tagged function also has the generated code under it, wrapped in the comments `# == Begin generated code ==` and `# == End generated code ==`
* When the interpreter reaches this function, it automatically runs it and calculates the generated code, then checks the current state of the file. If the generated code is already present, it does nothing more. If not present, it throws a GeneratedCodeNeedsUpdate exception.
* To handle these exceptions, you should make a script that calls update_all_generated_code() on the module - which repeatedly imports the module, catches exceptions, and performs the actual code updates. Also, any generated-code blocks not induced by a @generate_code function will be deleted by update_all_generated_code() (identified by their comments).
"""
import base64
import hashlib
import inspect
import importlib
import importlib.util
import os.path
import random
import re
import sys
# from collections import defaultdict
from typing import List

from atomicwrites import atomic_write

# lines_added_this_run = defaultdict(int)

# class _CodegenState():
#     def __init__(self, file_path):
#         self.file_path = file_path
#
# _codegen_states = {}

# These are magic strings; if you edit them, you'll have to update any existing generated-code files too, or the lines will cease to be acknowledged as machine-generated
generated_code_hash_length = 5
generated_code_line_label = " #{}"
generated_code_start_label = "# == Code generated by `{}` (lines in this chunk end with a hash to prevent uncertainty about what code is machine-generated; the system will automatically replace such lines, so don't edit them) =="
generated_code_end_label = "# == End of code generated by `{}` =="


def _parse_start_label(line):
    regex = re.escape(generated_code_start_label).replace(re.escape("{}"), "([^`]*)")
    # print(regex, line)
    match = re.match(regex, line)
    if not match: return None
    return match[1]
def _line_label_of_generated_code_line(line):
    return line[-(len(generated_code_line_label) - 2 + generated_code_hash_length):]


def _full_generated_lines(generator_name, fn_hash, raw_lines):
    start_label = generated_code_start_label.format(generator_name)
    line_label = generated_code_line_label.format(fn_hash)
    end_label = generated_code_end_label.format(generator_name)
    def labeled_line(raw_line):
        target_length = 80
        forced_length = len(raw_line) + len(line_label)
        return raw_line + " "*(target_length-forced_length) + line_label
    return [
        labeled_line(line) for line in
        [start_label] + raw_lines + [end_label]
    ]

def _gibberish_hash(digest):
    # ALWAYS mix letters, numbers, case, and never use vowels, so that it doesn't look like a word
    nonletters = "$&%@0123456789"
    letters = "bcdfghijklmnpqrstvwxyz"
    result = ""
    bytes = iter(digest)
    for i in range(generated_code_hash_length):
        # yeah these % have a bias; I don't need to care about that
        if ("_"+result)[-2:].isalpha() or next(bytes) < 100:
            result = result + nonletters[next(bytes) % len(nonletters)]
        else:
            char = letters[next(bytes) % len(letters)]
            if len(result) == 0 or result[-1].isupper() or (not result[-1].isalpha() and next(bytes) < 128):
                result = result + char
            else:
                result = result + char.upper()
    return result

def generate_code(code_generation_function):
    generator_name = code_generation_function.__name__
    # print(inspect.getsource(code_generation_function))
    hash_bytes = hashlib.blake2b(inspect.getsource(code_generation_function).encode()).digest()
    fn_hash = _gibberish_hash(hash_bytes)
    raw_generated_code = code_generation_function()
    raw_generated_lines = raw_generated_code.split("\n")
    file_path = inspect.getfile(code_generation_function)
    # 1-indexed
    code_generation_function_lines, code_generation_function_start_lineno = inspect.getsourcelines(code_generation_function)
    # 0-indexed
    lineidx_after_generator = (code_generation_function_start_lineno-1) + len(code_generation_function_lines) #+ lines_added_this_run[file_path]
    # first_existing_lineno_after_generated_code = code_generation_function_start_lineno + lines_added_this_run[file_path]

    # initially open read-only to check whether the code is there:
    needs_rewriting = False
    with open(file_path, "r") as file:
        old_code = file.read()
        existing_lines = old_code.splitlines()
        updated_lines = _lines_with_replacing_generated_code_at(lineidx_after_generator, existing_lines, _full_generated_lines(generator_name, fn_hash, raw_generated_lines))
        # corresponding_lines = existing_lines[lineidx_after_generator:][:len(full_generated_lines)]
        # # corresponding_lines = existing_lines[:first_existing_lineno_after_generated_code][:-len(full_generated_lines)]
        if updated_lines != existing_lines:
            new_code = "\n".join(updated_lines)

            # We need special handling for syntax errors, because if you put a syntax error in the generated code, you can't even rerun the generation.
            try:
                compile(source=new_code, filename=os.path.basename(file_path), mode="exec", optimize=0)
            except SyntaxError as e:
                # print([getattr(e, f) for f in dir(e)])
                line_idx = (e.lineno - 1) - lineidx_after_generator
                end_line_idx = (e.end_lineno - 1) - lineidx_after_generator
                # thought of putting this at the start, but don't want to affect line numbers
                # ['"Code disabled due to syntax error (see below)"']+
                error_reported_lines = ["# " + line for line in raw_generated_lines]
                error_reported_lines.insert(end_line_idx + 1, f'"{" "*e.offset}^ {e} "')
                # error_reported_lines.insert(line_idx - 1, f'" SyntaxError in generated code ({(line_idx,end_line_idx, e.lineno,e.end_lineno)}): "')
                updated_lines = _lines_with_replacing_generated_code_at(lineidx_after_generator, existing_lines, _full_generated_lines(generator_name, fn_hash, error_reported_lines))
                new_code = "\n".join(updated_lines)
            if new_code != old_code:
                raise GeneratedCodeNeedsUpdate(file_path, old_code, new_code)
            # print(f"mismatch: {corresponding_lines}, {full_generated_lines}")
            # needs_rewriting = True

    # if needs_rewriting:
    #     print(f"Rewriting generated code for {code_generation_function.__name__}")
    #
    #     # result_lines = existing_lines[:first_existing_lineno_after_generated_code]
    #     # try:
    #     #     existing_generated_code_back_index = first_existing_lineno_after_generated_code - 1
    #     #     if existing_lines[existing_generated_code_back_index] == end_label:
    #     #         existing_generated_code_start_index = existing_lines.index(generated_code_start_label, 0, existing_generated_code_back_index)
    #     #         result_lines = existing_lines[:existing_generated_code_start_index]
    #     #         lines_added_this_run[file_path] -= (first_existing_lineno_after_generated_code - existing_generated_code_start_index)
    #     # except (IndexError, ValueError):
    #     #     pass
    #     result_lines = existing_lines[:start_lineidx_for_generated_code]
    #
    #     first_lineno_afterwards = start_lineidx_for_generated_code
    #     try:
    #         if existing_lines[first_lineno_afterwards] == start_label:
    #             first_lineno_afterwards += 1
    #             while existing_lines[first_lineno_afterwards].endswith(generated_code_line_label):
    #                 first_lineno_afterwards += 1
    #             if existing_lines[first_lineno_afterwards] == end_label:
    #                 first_lineno_afterwards += 1
    #     except IndexError:
    #         pass
    #
    #     result_lines.extend(full_generated_lines)
    #     lines_added_this_run[file_path] += len(full_generated_lines)
    #     result_lines.extend(existing_lines[first_existing_lineno_after_generated_code:])
    #     result = "\n".join(result_lines)
    #     print(result)
    #
    #     # try:
    #     #     with atomic_write(file_path, overwrite=True) as file:
    #     #         file.write(result)
    #     # except IOError:
    #     #     print("Unable to rewrite source file")
    #
    #     exec("\n".join(full_generated_lines), code_generation_function.__globals__)

# def reload_if_changed():
#     pass

def _lines_with_removing_generated_code_before_first_generator(original_lines: List[str]) -> List[str]:
    i = 0
    result = []
    while i < len(original_lines):
        line = original_lines[i]
        # print(f"line {i}...")
        if line == "@generate_code":
            # print(f"found generator")
            result.extend(original_lines[i:])
            break
        start_of = _parse_start_label(line)
        if start_of is not None:
            # print(f"found generated code")
            label = _line_label_of_generated_code_line(line)
            while original_lines[i].endswith(label):
                # print(f"found more generated code")
                i += 1
            continue

        result.append(line)
        i += 1
    return result


def _lines_with_replacing_generated_code_at_start(original_lines: List[str], generated_lines: List[str]) -> List[str]:
    cleaned = _lines_with_removing_generated_code_before_first_generator(original_lines)
    return generated_lines + cleaned


def _lines_with_replacing_generated_code_at(lineidx_after_generator: int, original_lines: List[str], generated_lines: List[str]) -> List[str]:
    return original_lines[:lineidx_after_generator] + _lines_with_replacing_generated_code_at_start(original_lines[lineidx_after_generator:], generated_lines)


def _remove_generated_code_before_first_generator(file_path):
    with open(file_path, "r") as file:
        existing_lines = list(file.read().splitlines())
    cleaned = _lines_with_removing_generated_code_before_first_generator(existing_lines)
    if cleaned != existing_lines:
        with atomic_write(file_path, overwrite=True) as file:
            file.write("\n".join(cleaned))


class GeneratedCodeNeedsUpdate(Exception):
    def __init__(self, file_path, old_code, new_code):
        self.file_path = file_path
        self.old_code = old_code
        self.new_code = new_code
        assert (new_code != old_code), "Constructed GeneratedCodeNeedsUpdate when the code didn't change!"

    def execute(self):
        with open(self.file_path, "r") as file:
            if file.read() != self.old_code:
                raise RuntimeError("Threw GeneratedCodeNeedsUpdate but the file on disk changed before we handled the exception? (Theoretically this should happen almost instantly, AND this doesn't protect from overwrites if the timing is slightly different, but this exception is here to protect from me theoretically-potentially making mistakes in the code where GeneratedCodeNeedsUpdate is handled a macroscopic amount of time later)")
        with atomic_write(self.file_path, overwrite=True) as file:
            file.write(self.new_code)


def update_all_generated_code(module_name):
    if module_name in sys.modules:
        return
    module_spec = importlib.util.find_spec(module_name)
    file_path = module_spec.origin
    _remove_generated_code_before_first_generator(file_path)
    m = None
    for attempt in range(100):
        try:
            if m is None:
                m = importlib.import_module(module_name)
            else:
                vars(m).clear()
                importlib.reload(m)
            break
        except GeneratedCodeNeedsUpdate as e:
            # print("Generated code changed:", e.new_code)
            e.execute()
            continue
        except:
            import traceback
            ty, exc, tb = sys.exc_info()
            while inspect.getframeinfo(tb.tb_frame).filename != file_path:
                tb = tb.tb_next
            traceback.print_exception(ty, exc, tb)
            break
        #     print(f"Exception in code-generation file: \n{traceback.format_exc()}")


